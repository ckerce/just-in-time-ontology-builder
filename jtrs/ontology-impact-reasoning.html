<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JTOB & JTRS Unified Builder</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Marked.js for Preview -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        
        /* Markdown Preview Styles */
        .markdown-preview h1 { font-size: 1.8em; font-weight: bold; margin-top: 1em; margin-bottom: 0.5em; padding-bottom: 0.3em; border-bottom: 1px solid #e2e8f0; }
        .markdown-preview h2 { font-size: 1.5em; font-weight: bold; margin-top: 1.5em; margin-bottom: 0.5em; color: #1e293b; }
        .markdown-preview h3 { font-size: 1.25em; font-weight: bold; margin-top: 1.25em; margin-bottom: 0.5em; color: #334155; }
        .markdown-preview p { margin-bottom: 1em; line-height: 1.6; color: #374151; }
        .markdown-preview ul { list-style-type: disc; margin-left: 1.5em; margin-bottom: 1em; }
        .markdown-preview pre { background: #f8fafc; padding: 1em; border-radius: 0.5em; overflow-x: auto; border: 1px solid #e2e8f0; margin-bottom: 1em; }
        .markdown-preview code { font-family: monospace; background: #f1f5f9; padding: 0.2em 0.4em; border-radius: 0.25em; font-size: 0.9em; }
        .markdown-preview blockquote { border-left: 4px solid #3b82f6; padding-left: 1em; margin-left: 0; color: #4b5563; font-style: italic; background-color: #eff6ff; padding: 0.5rem; }
        .markdown-preview table { width: 100%; border-collapse: collapse; margin-bottom: 1em; }
        .markdown-preview th, .markdown-preview td { border: 1px solid #cbd5e1; padding: 0.5em; text-align: left; }
        .markdown-preview th { background-color: #f1f5f9; }
        
        /* Animations */
        @keyframes pulse-ring {
            0% { transform: scale(0.8); opacity: 0.5; }
            100% { transform: scale(1.3); opacity: 0; }
        }
        .animate-pulse-ring {
            animation: pulse-ring 1.5s cubic-bezier(0.215, 0.61, 0.355, 1) infinite;
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-900 h-screen overflow-hidden">
    <div id="root" class="h-full"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        // --- 1. GEMINI API INTEGRATION ---
        const apiKey = ""; // Execution environment key injection

        const GeminiService = {
            generate: async (userKey, prompt) => {
                const keyToUse = userKey || apiKey;
                if (!keyToUse) throw new Error("API Key missing");
                
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${keyToUse}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                    }
                );
                if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || "";
            }
        };

        // --- 2. DATA DEFINITIONS ---

        const MODE = { JTOB: 'JTOB', JTOB_IC: 'JTOB-IC', JTRS: 'JTRS' };

        // Phase titles for rendering
        const PHASE_TITLES = {
            [MODE.JTOB]: { 1: "REQUIREMENTS", 2: "MINIMAL STRUCTURE", 3: "CONSTRAINTS", 4: "VALIDATION", 5: "HANDOFF" },
            [MODE.JTOB_IC]: { 1: "REQUIREMENTS", 2: "MINIMAL STRUCTURE", 3: "CONSTRAINTS", 4: "VALIDATION", 5: "HANDOFF" },
            [MODE.JTRS]: { 1: "DECISION FRAMING", 2: "ANALOGICAL ANCHORING", 3: "CONCEPT REFINEMENT", 4: "INFERENCE PATTERNS", 5: "PERSPECTIVE ROTATION", 6: "STRESS TESTING", 7: "SYNTHESIS" }
        };

        // --- CONTENT DEFINITIONS ---
        // Merging content from original tool with styling flags from comparison tool
        
        const JTOB_SECTIONS = {
            "CORE": { title: "CORE PRINCIPLES", mode: "ALL", content: `Build minimal ontologies for specific purposes. Every concept, relationship, constraint, and assessment metric must justify its inclusion through actual use in required queries, artifacts, or decisions. Default to exclusion. Prefer implicit semantics. Operationalize nuanced judgments through evidence-based metrics. Validate empirically against concrete requirements.` },
            "WARNINGS": { title: "CRITICAL WARNINGS", mode: "ALL", content: `- Search to verify current tool versions, standards, and best practices before assuming\n- Do not speculate about future needs or build "comprehensive" assessment frameworks\n- Do not replicate domain knowledge unless it affects project decisions\n- Stop decomposition when further detail doesn't affect any outcome\n- Collapse metric distinctions that don't change decisions` },
            "1.1": { phase: 1, title: "1.1 Use Case Definition", mode: "ALL", content: `**Primary Purpose:** [One sentence: what this ontology enables]\n\n**Deliverables:** [Specific artifacts with examples]\n- [Deliverable 1: type and concrete example]\n\n**Decision Points:** [Specific choices/judgments required]\n- [Decision 1: what gets chosen/prioritized/allocated]\n\n**Tool Ecosystem:**\n- Primary tool: [Name, version - verify current]\n- Integration points: [Other tools, formats, standards]` },
            "1.2": { phase: 1, title: "1.2 Query Set", mode: "ALL", content: `*Define 5-10 literal questions that must be answerable. Tie each to a decision or artifact.*\n\n**Q1:** [Specific structural query]  \nâ†’ Supports: [Decision/artifact]  \nâ†’ Concepts needed: [Provisional list]\nâ†’ Requires discrimination: [Yes/No]` },
            "1.3": { phase: 1, title: "1.3 Discrimination Requirements", mode: "IC_ONLY", content: `*Extract from queries: which questions require nuanced judgment rather than binary classification?*\n\n**Discrimination Need 1:**\n- Query: [Which query requires this]\n- Decision impact: [What changes based on distinction]\n- Current poles: [Low end] â†â†’ [High end]\n- Justification: [Why binary insufficient]` },
            "1.4": { phase: 1, title: "1.4 Integration Points", mode: "ALL", content: `*Search and verify current versions of all external references.*\n\n**Reference Ontologies/Standards:**\n- [Name]: [Version - verified {date}]\n  - Mapping scope: [What must align]` },
            "2.1": { phase: 2, title: "2.1 Core Concepts", mode: "ALL", content: `*Extract via backward chaining: deliverables â†’ queries â†’ integration â†’ logical dependencies ONLY.*\n\n**[Concept Name]**\n- Definition: [At required precision level]\n- Justification: [Which deliverable/query/integration requires this]\n- Properties: [Only those used in queries/analyses]` },
            "2.2": { phase: 2, title: "2.2 Relationships", mode: "ALL", content: `*Include ONLY relationships that enable required traceability, analyses, views, or integrations.*\n\n**[Relationship Type]**\n- Definition: [Precise meaning]\n- Directionality: [Uni/bidirectional]\n- Domain â†’ Range: [Valid source types] â†’ [Valid target types]` },
            "2.3": { phase: 2, title: "2.3 Assessment Metrics", mode: "IC_ONLY", content: `*Only if discrimination requirements (1.3) cannot be met with concept properties alone.*\n\n**[Metric Name]**\n**Purpose:** [One sentence: what decision this enables]\n**Scale Type:** [Ordinal/Interval/Ratio]\n\n**Levels:**\n- **Level [X]:** [Label] - [Operational definition]` },
            "3.1": { phase: 3, title: "3.1 Validation Rules", mode: "ALL", content: `*Only rules that enforce consistency, validate constraints affecting decisions, or prevent invalidating errors.*\n\n**[Rule Name]**\n- Constraint: [Natural language statement]\n- Triggered by: [Which query/artifact needs this]\n- Violation impact: [What breaks]` },
            "3.2": { phase: 3, title: "3.2 Inference Rules", mode: "ALL", content: `*Only if: queries require derived information, analyses need calculated properties, or view generation needs transitive closure.*\n\n**[Rule Name]**\n- Purpose: [What query/analysis uses this]\n- Logic: If [X] and [Y], then [Z]` },
            "3.3": { phase: 3, title: "3.3 Metric Combination Rules", mode: "IC_ONLY", content: `*Only if multiple metrics must be combined for decisions.*\n\n**[Combination Rule Name]**\n- Purpose: [Which decision requires combined assessment]\n- Inputs: [Metric 1], [Metric 2]\n- Logic: [How to combine - formula or decision tree]` },
            "4.1": { phase: 4, title: "4.1 Query Execution", mode: "ALL", content: `*For each query from 1.2:*\n\n**Query:** [Original query text]\n- Answerable: [Yes/Partial/No]\n- Concepts used: [Actual concepts]\n- Example answer: [Concrete answer using example instances]` },
            "4.2": { phase: 4, title: "4.2 Artifact Generation", mode: "ALL", content: `*For each deliverable from 1.1:*\n\n**Deliverable:** [Name]\n**Coverage:**\n- Information present: [Yes/Partial/No]\n- Gaps: [Missing elements or NONE]` },
            "4.3": { phase: 4, title: "4.3 Metric Calibration", mode: "IC_ONLY", content: `*For each metric from 2.3:*\n\n**Metric:** [Name]\n**Calibration Set:** [10-15 known cases spanning metric range]\n| Case | Description | Expected | Result | Match? |\n|---|---|---|---|---|\n| [C1] | ... | L[X] | L[Y] | âœ“/âœ— |` },
            "4.4": { phase: 4, title: "4.4 Decision Impact Verification", mode: "IC_ONLY", content: `*For each discrimination requirement from 1.3:*\n\n**Discrimination:** [Name]\n**Decision:** [What gets chosen/prioritized]\n\n**Test Cases:**\n- Case A (Level [X]): â†’ Outcome [Y]\n- Case B (Level [X+1]): â†’ Outcome [Z]\n- Outcome differs: [Yes/No]` },
            "5.1": { phase: 5, title: "5.1 Summary", mode: "ALL", content: `**Purpose:** [One sentence from 1.1]\n**Capabilities:** This ontology supports [Capability 1], [Capability 2]\n**Metrics:**\n- Concepts: [N]\n- Relationships: [N]\n- Rules: [N]` },
            "5.2": { phase: 5, title: "5.2 Assumptions & Limitations", mode: "ALL", content: `**Key Assumptions:** [Assumption] | Verify via: [Method]\n**Known Limitations:** [What this cannot do] | Extension path: [How to add]\n**Dependencies:** Tools: [Name/version]` },
            "5.3": { phase: 5, title: "5.3 Assessment Protocol", mode: "IC_ONLY", content: `**[Metric Name]**\n- Current version: [X.Y] as of [Date]\n- Calibration status: [N cases, X% agreement]\n- Evidence requirements: [Types needed]` },
            "5.4": { phase: 5, title: "5.4 Evolution", mode: "ALL", content: `**Extension Triggers:** [New deliverable] â†’ [Process]\n**Stability Guarantees:** [What won't change]\n**Validation Cadence:** [Frequency]` }
        };

        const JTRS_SECTIONS = {
            "CORE": { title: "CORE PRINCIPLES", mode: "JTRS", content: `Scaffold reasoning for specific decisions. Every concept, distinction, inference pattern, and analogy must earn inclusion by affecting conclusions. Default to implicit understanding. Stop refining when further precision doesn't change outcomes. The scaffold is disposable â€” it shapes thinking, not artifacts.\n\n**Critical constraints:**\n- This is not a knowledge base specification â€” resist schema-building instincts\n- Concepts exist to support inferences, not to be catalogued\n- Analogies are load-bearing â€” choose carefully, note where they break\n- Precision is expensive â€” match refinement level to decision requirements\n- Perspectives are lenses, not truth â€” rotate deliberately` },
            "JTRS_1.1": { phase: 1, title: "1.1 Core Question", mode: "JTRS", content: `*What specific question must be answered or decision must be made?*\n\n**The Question:** [Single sentence, falsifiable or decidable]\n\n**Satisfying Answer Looks Like:**\n- Form: [Ranking / Classification / Estimate / Recommendation / Explanation]\n- Confidence requirement: [Rough directional / Calibrated probability / Defensible argument]\n- Action threshold: [What answer triggers what action?]\n\n**Non-Goals:** [What adjacent questions are we explicitly NOT answering?]` },
            "JTRS_1.2": { phase: 1, title: "1.2 Required Distinctions", mode: "JTRS", content: `*What discriminations must this reasoning make? Only those that affect the answer.*\n\n**Distinction 1:** [X] vs [Y]\n- Why it matters: [Different answer/action if X vs Y]\n- Evidence type that separates them: [What would you look for?]\n- Acceptable ambiguity: [Can we tolerate uncertainty here? Y/N]\n\n**Collapse Test:** For each distinction, ask: "If I couldn't make this distinction, would my answer materially change?" If no â†’ remove.` },
            "JTRS_1.3": { phase: 1, title: "1.3 Information Landscape", mode: "JTRS", content: `*What do we know, what can we learn, what remains uncertain?*\n\n**Known:** [Facts we can treat as given]\n**Discoverable:** [Information that exists and could be obtained]\n**Unknowable:** [Genuine uncertainty that won't resolve]\n**Assumed:** [Positions we're taking without proof â€” make explicit]` },
            "JTRS_2.1": { phase: 2, title: "2.1 Structural Analogues", mode: "JTRS", content: `*What well-understood domains share reasoning patterns with this problem?*\n\n**Analogue 1:** [Domain]\n- Structural similarity: [What maps?]\n- Borrowed vocabulary: [Terms we can import]\n- **Where it breaks:** [Critical disanalogies â€” these matter most]\n- Import with caution: [Inferences that seem to transfer but might not]\n\n**Analogue Selection Criteria:**\n- Prefer analogues where you have strong intuitions about edge cases\n- Prefer analogues with established reasoning frameworks\n- Avoid analogues that are themselves contested/poorly understood` },
            "JTRS_2.2": { phase: 2, title: "2.2 Adjacent Vocabularies", mode: "JTRS", content: `*What existing frameworks partially apply?*\n\n**Framework:** [Name]\n- Applicable concepts: [What translates?]\n- Inapplicable concepts: [What doesn't â€” and why?]\n- Translation friction: [Where does the framework's vocabulary mislead for our context?]` },
            "JTRS_3.1": { phase: 3, title: "3.1 Refinement Ladders", mode: "JTRS", content: `*For each key concept, map the spectrum from vague to operational.*\n\n**Concept:** [Name]\n\n| Level | Expression | Sufficient For |\n|-------|------------|----------------|\n| Colloquial | [How a layperson would say it] | [Casual discussion] |\n| Technical | [Domain-expert language] | [Expert communication] |\n| Operational | [Observable, measurable criteria] | [Actual decisions] |\n\n**Required Level for This Problem:** [Which level, and why?]\n\n**Refinement Stop Rule:** When two people applying the operational definition would reach the same conclusion on test cases, stop.` },
            "JTRS_3.2": { phase: 3, title: "3.2 Distinguishing Questions", mode: "JTRS", content: `*What questions, when answered, let you identify/classify instances?*\n\n**Concept:** [Name]\n- Q1: [Question that partitions instances]\n- Q2: [Follow-up that further refines]\n- Stopping condition: [When is classification sufficient?]` },
            "JTRS_3.3": { phase: 3, title: "3.3 Boundary Cases", mode: "JTRS", content: `*Where does this concept become ambiguous? These reveal hidden assumptions.*\n\n**Concept:** [Name]\n- Clear positive case: [Unambiguous instance]\n- Clear negative case: [Unambiguous non-instance]  \n- Contested boundary: [Case where reasonable people disagree]\n- **What the boundary case reveals:** [Hidden assumption or under-specification]` },
            "JTRS_4.1": { phase: 4, title: "4.1 Licensed Inferences", mode: "JTRS", content: `*What does knowing X allow you to conclude about Y, and under what conditions?*\n\n**Pattern:** [Name]\n- If: [Evidence / observation / established fact]\n- Then: [Conclusion]\n- Confidence: [Deductive / Strong inductive / Weak inductive / Speculative]\n- Defeaters: [What would block this inference?]\n- Example: [Concrete instance]\n\n**Inference Types to Distinguish:**\n- **Definitional:** Follows from meaning (â‰ˆ certain)\n- **Causal:** X brings about Y (requires mechanism)\n- **Correlational:** X and Y co-occur (no direction)\n- **Abductive:** Y would explain X (weakest)` },
            "JTRS_4.2": { phase: 4, title: "4.2 Inference Gaps", mode: "JTRS", content: `*What CAN'T be inferred from available information?*\n\n**Gap:** [Desired conclusion]\n- Missing link: [What additional information would be needed?]\n- Workaround: [Proxy, assumption, or explicit uncertainty?]` },
            "JTRS_4.3": { phase: 4, title: "4.3 Confidence Calibration", mode: "JTRS", content: `*How should uncertainty propagate through chained inferences?*\n\n**Rule:** [e.g., "Weakest-link" / "Probabilistic combination" / "Flag and continue"]\n**Threshold for action:** [What confidence level is sufficient for the decision at hand?]` },
            "JTRS_5.1": { phase: 5, title: "5.1 Stakeholder Frames", mode: "JTRS", content: `*How does the problem look from different vantage points?*\n\n**Perspective:** [Role/stakeholder]\n- What they see: [Salient features from this view]\n- What they don't see: [Blind spots]\n- What they value: [Optimization target]\n- Vocabulary shift: [Same concept, different name or emphasis]` },
            "JTRS_5.2": { phase: 5, title: "5.2 Frame Conflicts", mode: "JTRS", content: `*Where do perspectives produce incompatible conclusions?*\n\n**Conflict:** [Description]\n- Perspective A concludes: [X]\n- Perspective B concludes: [Y]\n- Source of divergence: [Different values? Different information? Different models?]\n- Resolution strategy: [Privilege one? Synthesize? Acknowledge irreducible tension?]` },
            "JTRS_5.3": { phase: 5, title: "5.3 Temporal Frames", mode: "JTRS", content: `*How does the problem look at different time scales?*\n\n- Immediate: [What matters now?]\n- Medium-term: [What matters over project/cycle horizon?]\n- Long-term: [What matters at strategic scale?]\n- **Temporal conflicts:** [Where do short and long-term views disagree?]` },
            "JTRS_6.1": { phase: 6, title: "6.1 Edge Case Probes", mode: "JTRS", content: `*What cases would break this reasoning structure?*\n\n**Probe 1:** [Extreme or unusual case]\n- Expected behavior: [What should the reasoning produce?]\n- Actual behavior: [Walk through â€” does it work?]\n- Failure mode: [If it breaks, how?]` },
            "JTRS_6.2": { phase: 6, title: "6.2 Weakest Links", mode: "JTRS", content: `*Where is confidence lowest in the chain?*\n\n**Weakest inference:** [Pattern name from 4.1]\n- Why it's weak: [Evidence thin? Analogy stretched? Assumption contestable?]\n- Impact if wrong: [Does the whole conclusion collapse, or just need adjustment?]\n- Mitigation: [Can we hedge? Gather more evidence? Accept uncertainty?]` },
            "JTRS_6.3": { phase: 6, title: "6.3 Hidden Assumptions Audit", mode: "JTRS", content: `*What are we taking for granted that could be false?*\n\n| Assumption | Impact if Wrong | Probability Wrong | Action |\n|------------|-----------------|-------------------|--------|\n| [Assumption] | [Consequences] | [H/M/L] | [Monitor / Test / Accept] |` },
            "JTRS_7.1": { phase: 7, title: "7.1 Reasoning Trace", mode: "JTRS", content: `*Reconstructed path from question to answer.*\n\n1. Starting question: [From 1.1]\n2. Key distinctions made: [From 1.2]\n3. Analogical grounding: [From 2.1 â€” what transferred]\n4. Critical inferences: [From 4.1 â€” the load-bearing ones]\n5. Perspective synthesis: [From 5.x â€” whose view dominated, why]\n6. Conclusion: [The answer]\n7. Confidence: [Calibrated assessment]\n8. Caveats: [What could overturn this]` },
            "JTRS_7.2": { phase: 7, title: "7.2 Residual Uncertainty", mode: "JTRS", content: `*What we still don't know, and whether it matters.*\n\n**Known unknowns:** [Explicit uncertainties]\n**Suspected unknowns:** [Things we might be missing]\n**Decision robustness:** [Does the conclusion survive reasonable uncertainty ranges?]` },
            "JTRS_7.3": { phase: 7, title: "7.3 Scaffold Dissolution", mode: "JTRS", content: `*This structure has served its purpose. What persists?*\n\n- **Portable insight:** [What did we learn that transfers beyond this problem?]\n- **Reusable patterns:** [Any inference patterns worth preserving?]\n- **Updated priors:** [How should this analysis change future reasoning?]\n- **Discard:** [Everything else â€” the scaffold was disposable]` }
        };

        const ALL_SECTIONS = { ...JTOB_SECTIONS, ...JTRS_SECTIONS };
        const JTRS_ANTI_PATTERNS = `## ANTI-PATTERNS (JTRS)\n\nâŒ **Schema-building instinct**: Creating entity-relationship structures when you need inference patterns\nâœ“ **Ask instead**: "What does knowing X let me conclude?" not "What are X's properties?"\n... (See scaffold documentation for full list)`;

        const INITIAL_STATE = {
            mode: MODE.JTOB,
            configName: 'My_Template',
            domainContext: '', 
            userApiKey: '', 
            sections: Object.keys(ALL_SECTIONS).reduce((acc, key) => {
                const sec = ALL_SECTIONS[key];
                // Default visibility logic
                let enabled = false;
                if (sec.mode === "JTRS") enabled = true; 
                else if (sec.mode === "ALL") enabled = true;
                acc[key] = { enabled };
                return acc;
            }, {}),
            customInstructions: {},
            globalSettings: { includeCore: true, includeWarnings: true, includeAntiPatterns: true }
        };

        // --- 3. COMPONENTS ---

        const Icon = ({ name, size = 16, className = "" }) => {
            React.useEffect(() => { if (window.lucide) window.lucide.createIcons(); }, [name]);
            return <i data-lucide={name} className={className} style={{ width: size, height: size, display: 'inline-block' }}></i>;
        };

        const SectionToggle = ({ id, def, state, onToggle, onCustomize }) => {
            // Visual Coding: Orange for JTRS, Purple for Impact, Blue for Ontology
            const borderColor = def.mode === 'JTRS' ? 'border-orange-500' : (def.mode === 'IC_ONLY' ? 'border-purple-500' : 'border-blue-500');
            const bgColor = def.mode === 'JTRS' ? 'bg-orange-50' : (def.mode === 'IC_ONLY' ? 'bg-purple-50' : 'bg-blue-50');
            const textColor = def.mode === 'JTRS' ? 'text-orange-900' : (def.mode === 'IC_ONLY' ? 'text-purple-900' : 'text-slate-700');
            
            return (
                <div className={`border-l-2 pl-3 py-2 mb-2 transition-all ${state.sections[id]?.enabled ? `${borderColor} ${bgColor}` : 'border-gray-200 opacity-60 hover:opacity-100'}`}>
                    <div className="flex items-center justify-between">
                        <div className="flex items-center space-x-2">
                            <input 
                                type="checkbox" 
                                checked={state.sections[id]?.enabled || false} 
                                onChange={() => onToggle(id)}
                                className={`w-4 h-4 rounded focus:ring-2 ${def.mode==='JTRS'?'text-orange-600 focus:ring-orange-500':'text-blue-600 focus:ring-blue-500'}`}
                            />
                            <span className={`text-sm font-medium ${textColor}`}>
                                {def.title}
                                {def.mode === 'IC_ONLY' && <span className="ml-2 text-[10px] bg-purple-100 text-purple-800 px-1 rounded border border-purple-200">IC</span>}
                                {def.mode === 'JTRS' && <span className="ml-2 text-[10px] bg-orange-100 text-orange-800 px-1 rounded border border-orange-200">Reasoning</span>}
                            </span>
                        </div>
                        <button onClick={() => onCustomize(id)} className="text-gray-400 hover:text-blue-500"><Icon name="edit-2" size={14} /></button>
                    </div>
                    {state.sections[id]?.enabled && state.customInstructions[id] && (
                        <div className="mt-2 text-xs bg-yellow-50 border border-yellow-200 p-2 rounded text-yellow-800 flex items-start gap-2 animate-in fade-in slide-in-from-top-1">
                            <Icon name="sticky-note" size={12} className="mt-0.5 shrink-0" />
                            <span className="italic line-clamp-2">{state.customInstructions[id]}</span>
                        </div>
                    )}
                </div>
            );
        };

        const App = () => {
            const [state, setState] = useState(() => {
                const saved = localStorage.getItem('jtob_unified_config');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    return { ...INITIAL_STATE, ...parsed, sections: { ...INITIAL_STATE.sections, ...parsed.sections } };
                }
                return INITIAL_STATE;
            });

            const [customizingId, setCustomizingId] = useState(null);
            const [previewMd, setPreviewMd] = useState('');
            const [isGenerating, setIsGenerating] = useState(false);
            const [luckyLoading, setLuckyLoading] = useState(false);

            useEffect(() => { localStorage.setItem('jtob_unified_config', JSON.stringify(state)); }, [state]);
            useEffect(() => { generateTemplate(); }, [state]);

            const generateTemplate = () => {
                const date = new Date().toISOString().split('T')[0];
                let title = state.mode === MODE.JTRS ? 'JUST-IN-TIME REASONING SCAFFOLD' : (state.mode === MODE.JTOB_IC ? 'JTOB WITH IMPACT CONSIDERATIONS' : 'JUST-IN-TIME ONTOLOGY BUILDER');
                let md = `# ${title}\nVERSION: ${state.mode === MODE.JTRS ? '1.0' : '3.0'}\nDATE: ${date}\nTEMPLATE: ${state.configName}\n`;
                if (state.domainContext) md += `DOMAIN: ${state.domainContext}\n`;
                md += `\n`;

                if (state.globalSettings.includeCore) md += `## CORE PRINCIPLES\n\n${(state.mode === MODE.JTRS ? JTRS_SECTIONS.CORE : JTOB_SECTIONS.CORE).content}\n\n---\n\n`;

                const phases = state.mode === MODE.JTRS ? [1,2,3,4,5,6,7] : [1,2,3,4,5];
                phases.forEach(phaseNum => {
                    const sectionsInPhase = Object.keys(ALL_SECTIONS).filter(k => {
                        const s = ALL_SECTIONS[k];
                        if (s.phase !== phaseNum) return false;
                        if (state.mode === MODE.JTRS) return s.mode === "JTRS";
                        if (state.mode === MODE.JTOB) return s.mode !== "JTRS" && s.mode !== "IC_ONLY";
                        return s.mode !== "JTRS";
                    });

                    if (sectionsInPhase.some(k => state.sections[k]?.enabled)) {
                        md += `## PHASE ${phaseNum}: ${PHASE_TITLES[state.mode][phaseNum]}\n\n`;
                        sectionsInPhase.forEach(k => {
                            if (state.sections[k]?.enabled) {
                                md += `### ${ALL_SECTIONS[k].title}\n\n`;
                                if (state.customInstructions[k]) md += `> ðŸ’¡ **Guidance:** ${state.customInstructions[k]}\n\n`;
                                md += `${ALL_SECTIONS[k].content}\n\n`;
                            }
                        });
                        md += `---\n\n`;
                    }
                });
                
                if (state.mode === MODE.JTRS && state.globalSettings.includeAntiPatterns) md += JTRS_ANTI_PATTERNS;
                
                setPreviewMd(md);
            };

            const handleImFeelingLucky = async () => {
                if (!state.userApiKey || !state.domainContext) return alert("API Key and Domain Context required.");
                setLuckyLoading(true);
                try {
                    // Logic: Configuration Agent (Smarter, Minimalist)
                    const validKeys = Object.keys(ALL_SECTIONS).filter(k => {
                        const s = ALL_SECTIONS[k];
                        if (state.mode === MODE.JTRS) return s.mode === "JTRS";
                        if (state.mode === MODE.JTOB) return s.mode !== "JTRS" && s.mode !== "IC_ONLY";
                        return s.mode !== "JTRS";
                    });

                    const prompt = `Act as an expert in the ${state.mode} framework. Context: "${state.domainContext}".
                    Task: Configure a MINIMAL VIABLE scaffold.
                    1. Select ONLY critical sections from: ${JSON.stringify(validKeys)}.
                    2. For JTRS, include JTRS_1.1, JTRS_4.1, JTRS_6.2.
                    3. Generate specific guidance strings for the 3 most important sections.
                    Return JSON: { "enabledSections": ["key"], "customInstructions": { "key": "instruction" } }`;

                    const res = await GeminiService.generate(state.userApiKey, prompt);
                    const config = JSON.parse(res.match(/\{[\s\S]*\}/)[0]);

                    setState(prev => {
                        const next = { ...prev, sections: { ...prev.sections }, customInstructions: { ...prev.customInstructions, ...config.customInstructions } };
                        validKeys.forEach(k => next.sections[k].enabled = false); // Reset current mode
                        config.enabledSections.forEach(k => { if(next.sections[k]) next.sections[k].enabled = true; });
                        return next;
                    });
                } catch (e) { console.error(e); alert("Auto-config failed."); }
                finally { setLuckyLoading(false); }
            };

            return (
                <div className="flex h-full flex-col md:flex-row bg-slate-50 relative">
                    {/* OVERLAY: Thinking State (Adapted from comparison tool) */}
                    {luckyLoading && (
                        <div className="absolute inset-0 bg-white/80 z-50 flex flex-col items-center justify-center backdrop-blur-sm animate-in fade-in">
                            <div className="w-16 h-16 border-4 border-orange-200 border-t-orange-500 rounded-full animate-spin mb-4"></div>
                            <h3 className="text-xl font-bold text-slate-800">Designing Scaffold...</h3>
                            <p className="text-slate-500">Analyzing "{state.domainContext}" to select minimal viable structure.</p>
                        </div>
                    )}

                    <div className="w-full md:w-5/12 flex flex-col border-r border-slate-200 bg-white h-full">
                        <div className="p-4 border-b border-slate-200 bg-slate-50">
                            <h1 className="text-xl font-bold text-slate-800 mb-4 flex items-center gap-2"><Icon name="layout" className="text-orange-600"/> Unified Builder</h1>
                            
                            {/* Mode Toggles: Better Labels */}
                            <div className="flex bg-slate-200 p-1 rounded-lg mb-4">
                                <button className={`flex-1 py-1.5 text-xs font-bold rounded ${state.mode===MODE.JTOB?'bg-white text-blue-700 shadow':'text-slate-500'}`} onClick={()=>setState(s=>({...s, mode:MODE.JTOB}))}>ONTOLOGY</button>
                                <button className={`flex-1 py-1.5 text-xs font-bold rounded ${state.mode===MODE.JTOB_IC?'bg-white text-purple-700 shadow':'text-slate-500'}`} onClick={()=>setState(s=>({...s, mode:MODE.JTOB_IC}))}>IMPACT</button>
                                <button className={`flex-1 py-1.5 text-xs font-bold rounded ${state.mode===MODE.JTRS?'bg-white text-orange-700 shadow':'text-slate-500'}`} onClick={()=>setState(s=>({...s, mode:MODE.JTRS}))}>REASONING</button>
                            </div>

                            {/* API Key */}
                            <div className="bg-slate-800 p-3 rounded-lg mb-4 text-slate-200">
                                <div className="flex justify-between mb-2">
                                    <span className="text-xs font-bold text-blue-400 flex gap-1"><Icon name="sparkles" size={12}/> GEMINI API</span>
                                    <input type="password" placeholder="Paste Key" className="bg-slate-700 border-none rounded px-2 py-0.5 text-xs w-32" value={state.userApiKey} onChange={e=>setState(s=>({...s, userApiKey:e.target.value}))} />
                                </div>
                            </div>

                            {/* Domain Context */}
                            <div>
                                <label className="text-xs font-bold text-slate-500 uppercase">Domain / Context</label>
                                <div className="flex gap-2 mt-1">
                                    <input type="text" className="flex-1 text-sm border p-2 rounded" placeholder="e.g. Pivot to B2C" value={state.domainContext} onChange={e=>setState(s=>({...s, domainContext:e.target.value}))} />
                                    <button onClick={handleImFeelingLucky} disabled={!state.userApiKey} className={`px-3 rounded text-white text-xs font-bold uppercase tracking-wider flex items-center gap-1 ${state.userApiKey?'bg-gradient-to-r from-orange-400 to-pink-500 hover:shadow-lg':'bg-slate-300'}`}>
                                        <Icon name="wand-2" size={14}/> Lucky
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div className="flex-1 overflow-y-auto p-4">
                            {(state.mode === MODE.JTRS ? [1,2,3,4,5,6,7] : [1,2,3,4,5]).map(phase => {
                                // Filter logic
                                const sections = Object.keys(ALL_SECTIONS).filter(k => {
                                    const s = ALL_SECTIONS[k];
                                    if (s.phase !== phase) return false;
                                    if (state.mode === MODE.JTRS) return s.mode === "JTRS";
                                    if (state.mode === MODE.JTOB) return s.mode !== "JTRS" && s.mode !== "IC_ONLY";
                                    return s.mode !== "JTRS";
                                });
                                if (!sections.length) return null;
                                
                                return (
                                    <div key={phase} className="mb-4">
                                        <h3 className={`text-xs font-bold uppercase mb-2 p-1 rounded ${state.mode===MODE.JTRS?'text-orange-600 bg-orange-50':'text-blue-600 bg-blue-50'}`}>Phase {phase}: {PHASE_TITLES[state.mode][phase]}</h3>
                                        <div className="pl-2">{sections.map(k => (
                                            <SectionToggle key={k} id={k} def={ALL_SECTIONS[k]} state={state} onToggle={id => setState(prev => {
                                                const ns = {...prev.sections}; ns[id] = { enabled: !ns[id]?.enabled }; return {...prev, sections: ns};
                                            })} onCustomize={setCustomizingId} />
                                        ))}</div>
                                    </div>
                                );
                            })}
                        </div>
                    </div>

                    <div className="w-full md:w-7/12 bg-white flex flex-col h-full">
                         <div className="p-3 border-b flex justify-between bg-slate-50">
                            <span className="text-xs font-bold text-slate-500 self-center">PREVIEW</span>
                            <button onClick={() => navigator.clipboard.writeText(previewMd)} className="text-slate-600 hover:text-blue-600 text-sm flex gap-1 items-center"><Icon name="copy" size={14}/> Copy</button>
                        </div>
                        <div className="flex-1 overflow-y-auto p-8"><div className="markdown-preview max-w-3xl mx-auto" dangerouslySetInnerHTML={{ __html: marked.parse(previewMd) }} /></div>
                    </div>
                </div>
            );
        };
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
